/*jshint esversion:6*/

$(function () {
    const vieo = $("video")[0];

    var model;
    var cameraMode = "environment"; // or "user"

    const startVideoStreamPromise = navigator.mediaDevices
        .getUserMedia({
            audio: false,
            video: {
                facingMode: cameraMode
            }
        })
        .then(function (stream) {
            return new Promise(function (resolve) {
                video.srcObject = stream;
                video.onloadeddata = function () {
                    video.play();
                    resolve();
                };
            });
        });

    var publishable_key = "rf_vqonodBKvZhOSKm8glHVdlatY3S2";
    var toLoad = {
        model: "cash-counter",
        version: 10
    };

    const loadModelPromise = new Promise(function (resolve, reject) {
        roboflow
            .auth({
                publishable_key: publishable_key
            })
            .load(toLoad)
            .then(function (m) {
                model = m;
                resolve();
            });
    });

    Promise.all([startVideoStreamPromise, loadModelPromise]).then(function () {
        $("body").removeClass("loading");
        resizeCanvas();
        detectFrame();
    });

    var canvas, ctx;
    const font = "16px sans-serif";

    function videoDimensions(video) {
        // Ratio of the video's intrisic dimensions
        var videoRatio = video.videoWidth / video.videoHeight;

        // The width and height of the video element
        var width = video.offsetWidth,
            height = video.offsetHeight;

        // The ratio of the element's width to its height
        var elementRatio = width / height;

        // If the video element is short and wide
        if (elementRatio > videoRatio) {
            width = height * videoRatio;
        } else {
            // It must be tall and thin, or exactly equal to the original ratio
            height = width / videoRatio;
        }

        return {
            width: width,
            height: height
        };
    }

    $(window).resize(function () {
        resizeCanvas();
    });

    const resizeCanvas = function () {
        $("canvas").remove();

        canvas = $("<canvas/>");

        ctx = canvas[0].getContext("2d");

        var dimensions = videoDimensions(video);

        console.log(
            video.videoWidth,
            video.videoHeight,
            video.offsetWidth,
            video.offsetHeight,
            dimensions
        );

        canvas[0].width = video.videoWidth;
        canvas[0].height = video.videoHeight;

        canvas.css({
            width: dimensions.width,
            height: dimensions.height,
            left: ($(window).width() - dimensions.width) / 2,
            top: ($(window).height() - dimensions.height) / 2
        });

        $("body").append(canvas);
    };
    const renderPredictions = function (predictions) {
        var dimensions = videoDimensions(video);
        var scale = 1;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        predictions.forEach(function (prediction) {
            const x = prediction.bbox.x;
            const y = prediction.bbox.y;  
            
            const width = prediction.bbox.width;
            const height = prediction.bbox.height;

            // Draw the bounding box.
            ctx.strokeStyle = prediction.color;
            ctx.lineWidth = 4;
            ctx.strokeRect(
                (x - width / 2) / scale,
                (y - height / 2) / scale,
                width / scale,
                height / scale
            );

            // Draw the label background.
            ctx.fillStyle = prediction.color;
            const textWidth = ctx.measureText(prediction.class).width;
            const textHeight = parseInt(font, 10); // base 10
            ctx.fillRect(
                (x - width / 2) / scale,
                (y - height / 2) / scale,
                textWidth + 8,
                textHeight + 4
            );
        });

        predictions.forEach(function (prediction) {
            const classValueMapping = {
                "one": 1,
                "five": 5,
                "ten": 10,
                "fifty": 50,
                "twenty": 20,
            }
            const x = prediction.bbox.x;
            const y = prediction.bbox.y;
            const width = prediction.bbox.width;
            const height = prediction.bbox.height;

            // Draw the text last to ensure it's on top.
            ctx.font = font;
            ctx.textBaseline = "top";
            ctx.fillStyle = "#000000";
            ctx.fillText(
                "$"+classValueMapping[prediction.class],
                (x - width / 2) / scale + 4,
                (y - height / 2) / scale + 1
            );
        });
    };


    var prevTime;
    var pastFrameTimes = [];
    function detectFrame() {
        if (!model) {
            stopObjectDetection(); // Î™®Îç∏Ïù¥ ÏóÜÏùÑ Í≤ΩÏö∞ Í∞ùÏ≤¥ Ïù∏Ïãù Ï§ëÏßÄ
            return;
        }

        detectFrameInterval = setInterval(function () {
            model
                .detect(video)
                .then(function (predictions) {
                    // ÌÅ¥ÎûòÏä§ Ï†ïÎ≥¥Îßå Ï∂îÏ∂úÌïòÏó¨ detectionResults Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä
                    const classValueMapping = {
                        "one": 1,
                        "five": 5,
                        "ten": 10,
                        "fifty": 50,
                        "twenty": 20,
                    }

                    const classes = predictions.map(prediction => prediction.class);
                    let cla = classes[0]

                    const value = classValueMapping[cla] || 0;
                    // const keyValueObject = {
                    //     [cla]: value
                    //   };

                    detectionResults.push(cla);

                    // Í≤∞Í≥ºÎ•º ÏßëÌï©(Î∞∞Ïó¥)Ïóê Ï∂îÍ∞Ä
                    console.log("Detection Resultsx:", classes); // Í≤∞Í≥º Ï∂úÎ†•

                    console.log(value);
                    renderPredictions(predictions);

                    if (prevTime) {
                        pastFrameTimes.push(Date.now() - prevTime);
                        if (pastFrameTimes.length > 30) pastFrameTimes.shift();

                        var total = 0;
                        pastFrameTimes.forEach(function (t) {
                            total += t / 1000;
                        });

                        var fps = pastFrameTimes.length / total;
                        $("#fps").text(Math.round(fps));
                    }
                    prevTime = Date.now();
                    updateHTMLResults(predictions);
                })

                .catch(function (e) {
                    console.log("CAUGHT", e);
                    clearInterval(detectFrameInterval); // Ïò§Î•òÍ∞Ä Î∞úÏÉùÌïòÎ©¥ Í∞ùÏ≤¥ Ïù∏Ïãù Ï§ëÏßÄ
                });
        },); //0.5Ï¥àÎßàÎã§ Í∞ùÏ≤¥Í≤ÄÏ∂ú
    }
    function updateHTMLResults(predictions) {
        const classValueMapping = {
            "one": 1,
            "five": 5,
            "ten": 10,
            "fifty": 50,
            "twenty": 20,

        }
        const classes = predictions.map(prediction => prediction.class);
        let cla = classes[0]

        const value = classValueMapping[cla] || 0;



        const resultsContainer = document.getElementById("results-container");
        resultsContainer.innerHTML = "";

        predictions.forEach(function (prediction) {
            const resultElement = document.createElement("div");
            const finall = value * usd_price
            const formattedValue = finall.toLocaleString();
            
            // Í≤∞Í≥º Ï∂úÎ†• ÌååÌä∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚ûú
            resultElement.textContent = `üá∫üá∏ : $${value} ‚†Ä=‚†Äüá∞üá∑ : ‚Ç©${formattedValue}`;
            resultsContainer.appendChild(resultElement);
        });
    }




    // 
    //         }
    // -------------------------------------------------------------------------

    // Î≤ÑÌäº ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
    // document.getElementById("startDetection").addEventListener("click", function () {
    //     // Í∞ùÏ≤¥ Ïù∏Ïãù Î°úÏßÅÏùÑ ÏãúÏûë
    //     startObjectDetection();


    //     // 3Ï¥à ÌõÑ Í∞ùÏ≤¥ Ïù∏ÏãùÏùÑ Î©àÏ∂îÍ≥† Í≤∞Í≥ºÎ•º Ï∂úÎ†•Ìï©ÎãàÎã§.
    //     setTimeout(function () {
    //         stopObjectDetection();
    //         console.log("Í∞ùÏ≤¥ Ïù∏Ïãù Í≤∞Í≥º:", detectionResults);

    //         function findMode(arr) {
    //             let mode = null;
    //             let maxCount = 0;
    //             const count = {}; // ÌÅ¥ÎûòÏä§Î≥Ñ Îì±Ïû• ÌöüÏàòÎ•º Ï†ÄÏû•Ìï† Í∞ùÏ≤¥

    //             for (const item of arr) {
    //                 if (!count[item]) {
    //                     count[item] = 1;
    //                 } else {
    //                     count[item]++;
    //                 }

    //                 if (count[item] > maxCount) {
    //                     maxCount = count[item];
    //                     mode = item;
    //                 }
    //             }

    //             return mode;
    //         }

    //         // detectionResults Î∞∞Ïó¥ÏóêÏÑú Í∞ÄÏû• ÏûêÏ£º ÎÇòÌÉÄÎÇòÎäî ÌÅ¥ÎûòÏä§Î•º Ï∞æÏùå
    //         const mostFrequentClass = findMode(detectionResults.flat());
    //         if (mostFrequentClass === null) {
    //             console.log("Í≤ÄÏ∂úÎêú Í∞ùÏ≤¥Í∞Ä ÏóÜÏäµÎãàÎã§ Îã§Ïãú „Ñ±„Ñ±");
    //             // "Í≤ÄÏ∂úÎêú Í∞ùÏ≤¥Í∞Ä ÏóÜÏäµÎãàÎã§" Î©îÏãúÏßÄÎ•º HTMLÏóê Ï∂úÎ†•
    //             document.getElementById("result").textContent = "Í≤ÄÏ∂úÎêú Í∞ùÏ≤¥Í∞Ä ÏóÜÏäµÎãàÎã§ Îã§Ïãú „Ñ±„Ñ±";
    //         } else {
    //             console.log("Í∞ÄÏû• ÎßéÏù¥ Ï∂úÎ†•Îêú ÌÅ¥ÎûòÏä§:", mostFrequentClass);


    //             // console.log("Í∞ÄÏû• ÎßéÏù¥ Ï∂úÎ†•Îêú ÌÅ¥ÎûòÏä§:", mostFrequentClass);

    //             // "jpy_1000" -> 1000(Ïà´Ïûê)Î°ú Î≥ÄÍ≤Ω
    //             const numericValue = parseInt(mostFrequentClass.replace("JPY_", ""), 10);
    //             if (!isNaN(numericValue)) {
    //                 console.log("Ïà´ÏûêÎ°ú Î≥ÄÌôò: " + numericValue * jpy_price);
    //             } else {
    //                 console.log("No valid numeric value found in the class.");
    //             }

    //             // htmlÏóê Ï∂úÎ†•ÎêòÎäî Í∞í
    //             document.getElementById("result").textContent = "ÌôòÎ•† Í≥ÑÏÇ∞ Í∞í: " + numericValue * jpy_price;
    //         }
    //         detectionResults = [];
    //     }, 3000); // 3Ï¥à (3000 Î∞ÄÎ¶¨Ï¥à)
    // });


    let detectionResults = [];
    let detectFrameInterval;

    function startObjectDetection() {
        console.log("Ìï®Ïàò ÏãúÏûë");
        detectFrame()
    }

    function stopObjectDetection() {
        clearInterval(detectFrameInterval);   // detectframe Ïò§Î•òÎ°ú Ï†ïÏßÄÏãúÌÇ¥
    }

});

